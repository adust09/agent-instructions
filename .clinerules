# GENERAL ディレクトリのルール

# GIT からの内容

## Gitワークフロー
Reference: https://github.com/mizchi/ailab/.cline/rules/git.md

このドキュメントでは、コミットとプルリクエストの作成に関するベストプラクティスを説明します。

### コミットの作成

コミットを作成する際は、以下の手順に従います：

1. 変更の確認
   ```bash
   # 未追跡ファイルと変更の確認
   git status
   
   # 変更内容の詳細確認
   git diff
   
   # コミットメッセージのスタイル確認
   git log
   ```

2. 変更の分析
   - 変更または追加されたファイルの特定
   - 変更の性質（新機能、バグ修正、リファクタリングなど）の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. コミットメッセージの作成
   - 「なぜ」に焦点を当てる
   - 明確で簡潔な言葉を使用
   - 変更の目的を正確に反映
   - 一般的な表現を避ける

4. コミットの実行
   ```bash
   # 関連ファイルのみをステージング
   git add <files>

   # コミットメッセージの作成（HEREDOCを使用）
   git commit -m "$(cat <<'EOF'
   feat: ユーザー認証にResult型を導入

   - エラー処理をより型安全に
   - エラーケースの明示的な処理を強制
   - テストの改善

   🤖 ${K4}で生成
   Co-Authored-By: Claude noreply@anthropic.com
   EOF
   )"
   ```

### プルリクエストの作成

プルリクエストを作成する際は、以下の手順に従います：

1. ブランチの状態確認
   ```bash
   # 未コミットの変更確認
   git status
   
   # 変更内容の確認
   git diff
   
   # mainからの差分確認
   git diff main...HEAD
   
   # コミット履歴の確認
   git log
   ```

2. 変更の分析
   - mainから分岐後のすべてのコミットの確認
   - 変更の性質と目的の把握
   - プロジェクトへの影響評価
   - 機密情報の有無確認

3. プルリクエストの作成
   ```bash
   # プルリクエストの作成（HEREDOCを使用）
   gh pr create --title "feat: Result型によるエラー処理の改善" --body "$(cat <<'EOF'
   ## 概要

   エラー処理をより型安全にするため、Result型を導入しました。

   ## 変更内容

   - neverthrowを使用したResult型の導入
   - エラーケースの明示的な型定義
   - テストケースの追加

   ## レビューのポイント

   - Result型の使用方法が適切か
   - エラーケースの網羅性
   - テストの十分性
   EOF
   )"
   ```

### 重要な注意事項

1. コミット関連
   - 可能な場合は `git commit -am` を使用
   - 関係ないファイルは含めない
   - 空のコミットは作成しない
   - git設定は変更しない

2. プルリクエスト関連
   - 必要に応じて新しいブランチを作成
   - 変更を適切にコミット
   - リモートへのプッシュは `-u` フラグを使用
   - すべての変更を分析

3. 避けるべき操作
   - 対話的なgitコマンド（-iフラグ）の使用
   - リモートリポジトリへの直接プッシュ
   - git設定の変更

### コミットメッセージの例

```bash
# 新機能の追加
feat: Result型によるエラー処理の導入

# 既存機能の改善
update: キャッシュ機能のパフォーマンス改善

# バグ修正
fix: 認証トークンの期限切れ処理を修正

# リファクタリング
refactor: Adapterパターンを使用して外部依存を抽象化

# テスト追加
test: Result型のエラーケースのテストを追加

# ドキュメント更新
docs: エラー処理のベストプラクティスを追加
```

### プルリクエストの例

```markdown
## 概要

TypeScriptのエラー処理をより型安全にするため、Result型を導入しました。

## 変更内容

- neverthrowライブラリの導入
- APIクライアントでのResult型の使用
- エラーケースの型定義
- テストケースの追加

## 技術的な詳細

- 既存の例外処理をResult型に置き換え
- エラー型の共通化
- モック実装の改善

## レビューのポイント

- Result型の使用方法が適切か
- エラーケースの網羅性
- テストの十分性


---


# GLOBAL からの内容

# グローバルカスタムインストラクション

## 目次

- [基本原則](#基本原則)
- [セキュリティとプライバシー](#セキュリティとプライバシー)
- [コミュニケーションスタイル](#コミュニケーションスタイル)
- [応答フォーマット](#応答フォーマット)
- [技術的知識と専門性](#技術的知識と専門性)
- [問題解決アプローチ](#問題解決アプローチ)
- [タスク実行ワークフロー](#タスク実行ワークフロー)


## 基本原則

### ユーザープロファイル

- **ユーザーはミドルエンジニアクラス**であり、基本的な技術概念は理解しているが、高度な専門知識や最新のトレンドについては補足説明が必要な場合がある
- 説明は技術的に正確でありながらも、過度に専門的な用語の使用は避ける
- 基礎から応用へと段階的に説明し、理解を深める機会を提供する

### 1. 正確性と信頼性

- 提供する情報は正確で最新であることを確認する
- 不確かな情報には適切に注釈を付け、推測と事実を明確に区別する
- 情報源を適切に引用し、検証可能性を確保する

### 2. 効率性と簡潔さ

- 冗長な説明や不必要な前置きを避ける
- 重要なポイントを明確に伝え、本質的な情報に焦点を当てる
- 複雑な概念は段階的に説明し、理解しやすくする

## 応答フォーマット

### 一般的な応答構造

1. **要約または結論**: 最も重要なポイントを最初に提示
2. **詳細説明**: 必要に応じて詳細な情報や背景を提供
3. **例示または実装**: 具体例やコードサンプルを提供
4. **次のステップまたは代替案**: 追加のアクションや選択肢を提案
5. プログラム中のコメントは全て英語にすること

### コード関連の応答

- コードブロックは適切な言語タグを使用して表示
- **コードのコメントは全て英語で記述する**（国際的な開発環境での一貫性と理解しやすさのため）
- コードには十分なコメントと説明を付ける
- エラーハンドリングとエッジケースへの対応を含める
- 最適化とベストプラクティスを考慮する

### 技術的な説明

- 概念を階層的に説明し、基本から応用へと進める
- 図表やアナロジーを活用して複雑な概念を視覚化する
- 技術的な決定の背後にある理由や原則を説明する
- 異なる技術間のトレードオフを明確に示す

## セキュリティとプライバシー

### データ保護

- 個人を特定できる情報（PII）の取り扱いに関するベストプラクティスを遵守する
- データの暗号化、匿名化、最小化の原則を推奨する
- データ漏洩や不正アクセスのリスクを最小限に抑える対策を提案する

### セキュアコーディング

- OWASP Top 10などのセキュリティ脆弱性に対する認識を持つ
- 入力検証、出力エンコーディング、適切な認証と認可などのセキュリティ対策を実装する
- 依存関係の脆弱性スキャンと定期的な更新を推奨する

### コンプライアンス

- GDPR、CCPA、HIPAAなどの関連する規制と法的要件を考慮する
- セキュリティとプライバシーのバイデザインの原則を適用する
- 適切な監査ログとモニタリングの実装を推奨する

## 技術的知識と専門性

### プログラミング言語とフレームワーク

- 主要なプログラミング言語（JavaScript/TypeScript、Python、Java、Rustなど）に精通している
- モダンなフレームワーク（React、Next.js、Spring Bootなど）の知識を持つ
- 言語やフレームワークの最新バージョンの機能と変更点を把握している

### ソフトウェア開発プラクティス

- アジャイル開発、スクラム、カンバンなどの開発手法に精通している
- テスト駆動開発（TDD）、継続的インテグレーション/継続的デリバリー（CI/CD）の原則を理解している
- コードレビュー、ペアプログラミング、モブプログラミングなどの協働プラクティスを推奨する
- **コミュニティで最も一般的なライブラリの使用を優先する**（安定性、サポート、ドキュメントの充実度の観点から）

### アーキテクチャとデザインパターン

- マイクロサービス、モノリス、サーバーレスなどのアーキテクチャスタイルを理解している
- GOF デザインパターン、SOLID 原則、DDD（ドメイン駆動設計）などの設計手法に精通している
- スケーラビリティ、パフォーマンス、セキュリティを考慮したシステム設計を提案できる

## 問題解決アプローチ

### 分析と理解

1. 問題の本質と範囲を明確に定義する
2. 関連する制約条件と要件を特定する
3. 問題を小さな部分に分解し、段階的に対処する
4. 根本原因を特定するために体系的な分析を行う

### 解決策の設計

1. 複数の解決策を検討し、それぞれの長所と短所を評価する
2. 短期的な修正と長期的な改善を区別する
3. 既存のパターンやベストプラクティスを適用する
4. 解決策の実装コストと期待される効果のバランスを考慮する

### 実装とテスト

1. 明確で再現可能な手順を提供する
2. エッジケースとエラー条件を考慮する
3. テスト戦略と検証方法を提案する
4. **すべての新しい関数に対してユニットテストを作成する**
5. フィードバックに基づいて解決策を反復的に改善する
6. エラーや実行に複数回失敗する場合はシュミレート関数などを実装せず、ユーザーに相談する


---


# WORKFLOW からの内容

## タスク実行ワークフロー
Reference : https://github.com/kinopeee/cursorrules/blob/main/v5/.cursorrules

以下は、シニアエンジニアが定義した構造化されたタスク実行プロセスです。このワークフローに従うことで、効率的かつ正確にタスクを遂行できます。
- 2回以上トライしてもエラーが解消されない場合は、ユーザーに相談してください。

### 1. 指示の分析と計画

タスクに取り組む前に、以下の分析を行います：

- 主要なタスクを簡潔に要約する
- 記載された技術スタックを確認し、その制約内での実装方法を検討する
  **※ 技術スタックに記載のバージョンは変更せず、必要があれば必ず承認を得ること**
- 重要な要件と制約を特定する
- 潜在的な課題をリストアップする
- タスク実行のための具体的なステップを詳細に列挙する
- それらのステップの最適な実行順序を決定する

#### 重複実装の防止

実装前に以下の確認を行います：

- 既存の類似機能の有無
- 同名または類似名の関数やコンポーネント
- 重複するAPIエンドポイント
- 共通化可能な処理の特定

### 2. タスクの実行

- 特定したステップを一つずつ実行する
- 各ステップの完了後、簡潔に進捗を報告する
- 実装時は以下の点に注意する：
  - 適切なディレクトリ構造の遵守
  - 命名規則の一貫性維持
  - 共通処理の適切な配置

### 3. 品質管理と問題対応

- 各タスクの実行結果を迅速に検証する
- エラーや不整合が発生した場合は、以下のプロセスで対応する：
  1. 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
  2. 対策案の作成と実施
  3. 修正後の動作検証
  4. デバッグログの確認と分析

- 検証結果は以下の形式で記録する：
  1. 検証項目と期待される結果
  2. 実際の結果と差異
  3. 必要な対応策（該当する場合）

### 4. 最終確認

- すべてのタスクが完了したら、成果物全体を評価する
- 当初の指示内容との整合性を確認し、必要に応じて調整を行う
- 実装した機能に重複がないことを最終確認する
- 確認が終了したら差分をgit commitする

### 5. 結果報告

以下のフォーマットで最終的な結果を報告します：

```markdown
# 実行結果報告

## 概要
[全体の要約を簡潔に記述]

## 実行ステップ
1. [ステップ1の説明と結果]
2. [ステップ2の説明と結果]
...

## 最終成果物
[成果物の詳細や、該当する場合はリンクなど]

## 課題対応（該当する場合）
- 発生した問題と対応内容
- 今後の注意点

## 注意点・改善提案
- [気づいた点や改善提案があれば記述]
```

### 重要な注意事項

- 不明点がある場合は、作業開始前に必ず確認を取る
- 重要な判断が必要な場合は、その都度報告し、承認を得る
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案する
- **明示的に指示されていない変更は行わない** 必要と思われる変更がある場合は、まず提案として報告し、承認を得てから実施する
- **特に UI/UXデザインの変更（レイアウト、色、フォント、間隔など）は禁止**とし、変更が必要な場合は必ず事前に理由を示し、承認を得てから行う
- **技術スタックに記載のバージョン（APIやフレームワーク、ライブラリ等）を勝手に変更しない** 変更が必要な場合は、その理由を明確にして承認を得るまでは変更を行わない


---

---


# FRAMEWORK ディレクトリのルール

# NEXT.JS からの内容

# 技術スタック

## コア技術
- TypeScript: ^5.0.0
- Node.js: ^20.0.0
- Next.js: ^15.1.3
- React: ^19.0.0
- Tailwind CSS: ^3.4.17
- ESLint: ^9.0.0
- Prettier: ^8.0.0
- vitest: ^3.0.0

# API バージョン管理
## 重要な制約事項
- APIクライアントは `app/lib/api/client.ts` で一元管理
- AI モデルのバージョンは client.ts 内で厳密に管理
- これらのファイルは変更禁止（変更が必要な場合は承認が必要）：
  - client.ts  - AIモデルとAPI設定の中核
  - types.ts   - 型定義の一元管理
  - config.ts  - 環境設定の一元管理

## 実装規則
- AIモデルのバージョンは client.ts でのみ定義
- 型定義は必ず types.ts を参照
- 環境変数の利用は config.ts 経由のみ許可

---

# プロジェクト構成

以下のディレクトリ構造に従って実装を行ってください：

```
my-next-app/
├── app/
│   ├── api/                          # APIエンドポイント
│   │   └── [endpoint]/
│   │       └── route.ts
│   ├── components/                   # アプリケーションコンポーネント
│   │   ├── ui/                       # 基本UI（button, card等）
│   │   └── layout/                   # レイアウト関連
│   ├── hooks/                        # カスタムフック
│   ├── lib/                          # ユーティリティ
│   │   ├── api/                      # API関連処理
│   │   │   ├── client.ts             # 変更禁止: AIモデル設定
│   │   │   ├── types.ts              # 変更禁止: 型定義
│   │   │   └── config.ts             # 変更禁止: 環境設定
│   │   └── utils/                    # 共通関数
│   └── styles/                       # スタイル定義
```

### 配置ルール
- UIコンポーネント → `app/components/ui/`
- APIエンドポイント → `app/api/[endpoint]/route.ts`
- 共通処理 → `app/lib/utils/`
- API関連処理 → `app/lib/api/`

---

以上の内容を順守し、タスクを遂行してください。


---

---


# LANGUAGE ディレクトリのルール

# RUST からの内容

# Rust プロジェクト カスタムインストラクション

## 目次

- [基本原則](#基本原則)
- [コーディング規約](#コーディング規約)
- [プロジェクト構成](#プロジェクト構成)
- [エラー処理](#エラー処理)
- [テスト戦略](#テスト戦略)
- [パフォーマンス最適化](#パフォーマンス最適化)
- [依存関係管理](#依存関係管理)
- [ドキュメント](#ドキュメント)
- [セキュリティ考慮事項](#セキュリティ考慮事項)

## 基本原則

### 安全性と信頼性

- Rustの所有権システムとライフタイムを適切に活用し、メモリ安全性を確保する
- `unsafe`ブロックの使用は最小限に抑え、必要な場合は徹底的にドキュメント化する
- パニックを避け、適切なエラー処理を実装する

### パフォーマンスと効率性

- ゼロコスト抽象化を活用し、実行時オーバーヘッドを最小限に抑える
- 不必要なメモリ割り当てやコピーを避ける
- 適切な場合はジェネリクスとトレイトを使用して、型安全かつ効率的なコードを書く

### 保守性と可読性

- 明確で一貫性のある命名規則を使用する
- 複雑なロジックには適切なコメントを付ける
- 関数とモジュールの責任を明確に分離する

## コーディング規約

### 命名規則

- 変数、関数、メソッド: `snake_case`
- 型（構造体、列挙型、トレイト）: `PascalCase`
- 定数: `SCREAMING_SNAKE_CASE`
- マクロ: `snake_case!`
- モジュール: `snake_case`

### フォーマット

- `rustfmt`を使用して一貫したコードフォーマットを維持する
- デフォルトの設定を尊重し、プロジェクト固有のカスタマイズは最小限に抑える
- コミット前に必ず`cargo fmt`を実行する

### リンティング

- `clippy`を使用して一般的な問題やアンチパターンを検出する
- 警告は無視せず、適切に対処する

## プロジェクト構成

### ディレクトリ構造

```
my-rust-project/
├── Cargo.toml          # プロジェクト設定と依存関係
├── Cargo.lock          # 依存関係の正確なバージョン
├── src/                # ソースコード
│   ├── main.rs         # バイナリのエントリーポイント
│   ├── lib.rs          # ライブラリのルートモジュール
│   └── bin/            # 追加のバイナリ
├── tests/              # 統合テスト
├── benches/            # ベンチマーク
├── examples/           # 使用例
└── docs/               # ドキュメント
```

### モジュール構成

- 関連する機能を論理的なモジュールにグループ化する
- 公開APIは明示的に`pub`キーワードでマークし、必要最小限に抑える
- 内部実装の詳細は非公開に保つ

### ワークスペース

- 大規模プロジェクトではCargoワークスペースを使用して、複数のパッケージを管理する
- 共通の機能は再利用可能なクレートに分割する
- ワークスペースメンバー間の依存関係を明確に定義する

## エラー処理

### エラー型

- 意味のあるカスタムエラー型を定義する
- `thiserror`クレートを使用してエラー型の定義を簡素化する
- エラーメッセージは具体的で、問題の原因と可能な解決策を示す

### エラー伝播

- `?`演算子を使用してエラーを上位の呼び出し元に伝播する
- 必要に応じて`map_err`や`context`を使用してエラーに追加情報を付与する
- パニックではなく、`Result`型を返す関数を設計する

### 回復戦略

- エラーから回復可能な場合は、適切なフォールバックメカニズムを実装する
- クリティカルなエラーは明確に識別し、適切に処理する
- ユーザーに対しては、技術的な詳細ではなく、理解しやすいエラーメッセージを提供する

## テスト戦略

### ユニットテスト

- 各モジュールに対応するテストモジュールを作成する（`#[cfg(test)]`属性を使用）
- 公開APIと重要な内部関数の両方をテストする
- エッジケースとエラー条件を徹底的にテストする

### 統合テスト

- `tests/`ディレクトリに統合テストを配置する
- 実際のユースケースとワークフローをシミュレートする
- 外部依存関係との相互作用をテストする

### プロパティベーステスト

- `proptest`や`quickcheck`を使用して、プロパティベーステストを実装する
- 入力の広範囲な組み合わせに対してコードの動作を検証する
- 不変条件と事後条件を明確に定義する

### ドキュメントテスト

- ドキュメントコメント内のコード例が機能することを確認する
- 実際のユースケースを示す例を提供する
- `cargo test --doc`でドキュメントテストを実行する

## パフォーマンス最適化

### プロファイリング

- `criterion`を使用してベンチマークを作成し、パフォーマンスを測定する
- ホットパスを特定し、最適化の努力を集中させる
- 最適化の前後でベンチマークを実行し、改善を確認する

### メモリ効率

- 不必要なクローンやコピーを避ける
- 適切な場合は参照を使用する
- 大きなデータ構造には`Box`、`Rc`、`Arc`などのスマートポインタを使用する

### 並行処理

- 適切な場合は`rayon`を使用して並列処理を実装する
- スレッド安全性を確保するために、Rustの所有権システムを活用する
- 非同期処理には`tokio`や`async-std`などの成熟したランタイムを使用する

## 依存関係管理

### クレート選択

- **コミュニティで最も一般的なクレートの使用を優先する**
- クレートの選択基準：
  - メンテナンスの活発さ
  - ドキュメントの質
  - テストカバレッジ
  - 依存関係の数
  - ライセンスの互換性

### バージョニング

- セマンティックバージョニングを遵守する
- 依存関係のバージョンは適切に制約する（例：`^1.0.0`）
- 定期的に依存関係を更新し、セキュリティ脆弱性を回避する

### ベンダリング

- 必要に応じて`cargo vendor`を使用して、依存関係をベンダリングする
- オフラインビルドやエアギャップ環境での開発をサポートする
- ベンダリングされた依存関係の更新プロセスを確立する

## ドキュメント

### コードドキュメント

- すべての公開API要素に対して、ドキュメントコメント（`///`または`//!`）を提供する
- ドキュメントには以下を含める：
  - 機能の概要
  - パラメータと戻り値の説明
  - 使用例
  - エラー条件
  - パニック条件（該当する場合）

### READMEとガイド

- プロジェクトのREADMEには以下を含める：
  - プロジェクトの目的と機能
  - インストール手順
  - 基本的な使用例
  - ライセンス情報
- 複雑な機能には詳細なガイドを提供する

### ChangeLog

- セマンティックバージョニングに基づいて変更を記録する
- 各リリースの主要な変更、バグ修正、非互換性のある変更を文書化する
- 変更の理由と影響を説明する

## セキュリティ考慮事項

### 入力検証

- 外部からの入力は常に検証し、信頼しない
- パーサーには`nom`や`serde`などの十分にテストされたライブラリを使用する
- 入力サイズに制限を設け、DoS攻撃を防止する

### 機密データの処理

- 機密データを扱う際は`secrecy`や`zeroize`などのクレートを使用する
- メモリ内の機密データは使用後に確実に消去する
- 機密データをログに記録しない

### 依存関係のセキュリティ

- `cargo audit`を使用して、既知の脆弱性をチェックする
- CI/CDパイプラインにセキュリティスキャンを組み込む
- 依存関係を定期的に更新し、セキュリティパッチを適用する


---


# TS からの内容

## TypeScript
Reference : https://github.com/mizchi/ailab/blob/main/.cline/rules/typescript.md

TypeScriptでのコーディングにおける一般的なベストプラクティスをまとめます。

### 方針

- 最初に型と、それを処理する関数のインターフェースを考える
- コードのコメントとして、そのファイルがどういう仕様化を可能な限り明記する
- 実装が内部状態を持たないとき、 class による実装を避けて関数を優先する
- 副作用を抽象するために、アダプタパターンで外部依存を抽象し、テストではインメモリなアダプタで処理する


### 型の使用方針

1. 具体的な型を使用
   - any の使用を避ける
   - unknown を使用してから型を絞り込む
   - Utility Types を活用する

2. 型エイリアスの命名
   - 意味のある名前をつける
   - 型の意図を明確にする
   ```ts
   // Good
   type UserId = string;
   type UserData = {
     id: UserId;
     createdAt: Date;
   };

   // Bad
   type Data = any;
   ```

### エラー処理

1. Result型の使用
   ```ts
   import { Result, ok, err } from "npm:neverthrow";

   type ApiError = 
     | { type: "network"; message: string }
     | { type: "notFound"; message: string }
     | { type: "unauthorized"; message: string };

   async function fetchUser(id: string): Promise<Result<User, ApiError>> {
     try {
       const response = await fetch(`/api/users/${id}`);
       if (!response.ok) {
         switch (response.status) {
           case 404:
             return err({ type: "notFound", message: "User not found" });
           case 401:
             return err({ type: "unauthorized", message: "Unauthorized" });
           default:
             return err({ type: "network", message: `HTTP error: ${response.status}` });
         }
       }
       return ok(await response.json());
     } catch (error) {
       return err({ type: "network", message: error instanceof Error ? error.message : "Unknown error" });
     }
   }
   ```

2. エラー型の定義
   - 具体的なケースを列挙
   - エラーメッセージを含める
   - 型の網羅性チェックを活用

### 実装パターン

1. 関数ベース（状態を持たない場合）
   ```ts
   // インターフェース
   interface Logger {
     log(message: string): void;
   }

   // 実装
   function createLogger(): Logger {
     return {
       log(message: string): void {
         console.log(`[${new Date().toISOString()}] ${message}`);
       }
     };
   }
   ```

2. classベース（状態を持つ場合）
   ```ts
   interface Cache<T> {
     get(key: string): T | undefined;
     set(key: string, value: T): void;
   }

   class TimeBasedCache<T> implements Cache<T> {
     private items = new Map<string, { value: T; expireAt: number; }>();
     
     constructor(private ttlMs: number) {}
     
     get(key: string): T | undefined {
       const item = this.items.get(key);
       if (!item || Date.now() > item.expireAt) {
         return undefined;
       }
       return item.value;
     }
     
     set(key: string, value: T): void {
       this.items.set(key, {
         value,
         expireAt: Date.now() + this.ttlMs
       });
     }
   }
   ```

3. Adapterパターン（外部依存の抽象化）
   ```ts
   // 抽象化
   type Fetcher = <T>(path: string) => Promise<Result<T, ApiError>>;

   // 実装
   function createFetcher(headers: Record<string, string>): Fetcher {
     return async <T>(path: string) => {
       try {
         const response = await fetch(path, { headers });
         if (!response.ok) {
           return err({ type: "network", message: `HTTP error: ${response.status}` });
         }
         return ok(await response.json());
       } catch (error) {
         return err({ type: "network", message: error instanceof Error ? error.message : "Unknown error" });
       }
     };
   }

   // 利用
   class ApiClient {
     constructor(
       private readonly getData: Fetcher,
       private readonly baseUrl: string
     ) {}

     async getUser(id: string): Promise<Result<User, ApiError>> {
       return await this.getData(`${this.baseUrl}/users/${id}`);
     }
   }
   ```

### 実装の選択基準

1. 関数を選ぶ場合
   - 単純な操作のみ
   - 内部状態が不要
   - 依存が少ない
   - テストが容易

2. classを選ぶ場合
   - 内部状態の管理が必要
   - 設定やリソースの保持が必要
   - メソッド間で状態を共有
   - ライフサイクル管理が必要

3. Adapterを選ぶ場合
   - 外部依存の抽象化
   - テスト時のモック化が必要
   - 実装の詳細を隠蔽したい
   - 差し替え可能性を確保したい

### 一般的なルール

1. 依存性の注入
   - 外部依存はコンストラクタで注入
   - テスト時にモックに置き換え可能に
   - グローバルな状態を避ける

2. インターフェースの設計
   - 必要最小限のメソッドを定義
   - 実装の詳細を含めない
   - プラットフォーム固有の型を避ける

3. テスト容易性
   - モックの実装を簡潔に
   - エッジケースのテストを含める
   - テストヘルパーを適切に分離

4. コードの分割
   - 単一責任の原則に従う
   - 適切な粒度でモジュール化
   - 循環参照を避ける


---

---
